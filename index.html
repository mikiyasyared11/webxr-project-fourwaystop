<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Realistic 4-Way Stop â€¢ Physics & parallel Flow</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

  <script>
    /* ======================================================================
       SYSTEM: TRAFFIC ARBITER (The Brain)
       Handles Right-of-Way and Parallel Crossing Logic
       ====================================================================== */
    AFRAME.registerSystem('traffic-arbiter', {
      init() {
        this.queue = [];
        this.activeCars = []; // Array to allow multiple cars (parallel)
        this.minGap = 1000; 
        this.lastClearTime = 0;
      },

      registerArrival(carEl) {
        if (!this.queue.includes(carEl)) {
          this.queue.push(carEl);
        }
      },

      notifyClear(carEl) {
        // Remove from active list
        this.activeCars = this.activeCars.filter(c => c !== carEl);
        if (this.activeCars.length === 0) {
            this.lastClearTime = Date.now();
        }
      },

      tick() {
        const now = Date.now();

        // Only process if queue has cars and safety gap passed
        if (this.queue.length > 0 && this.activeCars.length === 0 && (now - this.lastClearTime > this.minGap)) {
            
            // 1. Pick the first car (Priority)
            const car1 = this.queue.shift();
            if (!car1 || !car1.parentNode) return;

            const car1Data = car1.components['car-controller'].data;
            const car1Intent = car1.components['car-controller'].intention;
            
            const batch = [car1];

            // 2. SMART CHECK: Can the 2nd car go simultaneously?
            // Condition: Opposing lanes AND both going Straight
            if (this.queue.length > 0) {
                const car2 = this.queue[0]; // Peek next
                const car2Data = car2.components['car-controller'].data;
                const car2Intent = car2.components['car-controller'].intention;

                const isOpposite = (car1Data.axis === car2Data.axis && car1Data.dir !== car2Data.dir);
                const bothStraight = (car1Intent === 'straight' && car2Intent === 'straight');

                if (isOpposite && bothStraight) {
                    // Success! Parallel flow.
                    this.queue.shift(); // Remove car2 from queue
                    batch.push(car2);
                    console.log("Parallel Crossing Initiated");
                }
            }

            // 3. Launch the batch
            batch.forEach(c => {
                this.activeCars.push(c);
                c.emit('proceed-signal');
            });
        }
      }
    });

    /* ======================================================================
       SYSTEM: TRAFFIC GENERATOR
       ====================================================================== */
    AFRAME.registerSystem('traffic-generator', {
      init() {
        this.timer = 0;
        this.interval = 4000;
        this.lanes = [
            { axis: 'z', dir: -1, color: '#c0392b' }, // N
            { axis: 'z', dir: 1,  color: '#2980b9' },  // S
            { axis: 'x', dir: 1,  color: '#f39c12' },  // E
            { axis: 'x', dir: -1, color: '#8e44ad' }   // W
        ];
        this.laneIdx = 0;
      },
      tick(t, dt) {
        this.timer += dt;
        if (this.timer > this.interval) {
            this.spawn();
            this.timer = 0;
            this.interval = 3500 + Math.random() * 2500;
        }
      },
      spawn() {
        const cfg = this.lanes[this.laneIdx];
        const car = document.createElement('a-entity');
        car.setAttribute('car-controller', {axis: cfg.axis, dir: cfg.dir, color: cfg.color});
        this.el.appendChild(car);
        // Randomize lane order slightly
        this.laneIdx = Math.floor(Math.random() * 4);
      }
    });

    /* ======================================================================
       COMPONENT: CAR CONTROLLER (Physics & Logic)
       ====================================================================== */
    AFRAME.registerComponent('car-controller', {
      schema: {
        axis: { default: 'z' },
        dir: { type: 'number' },
        color: { type: 'color', default: 'red' },
        maxSpeed: { default: 8 }
      },

      init() {
        this.laneOffset = 2.0; 
        this.stopTarget = 8.0; // Distance from center to stop line (bumper at 6.5)
        
        // Physics State
        this.currentSpeed = 0;
        this.acceleration = 5.0; // m/s^2
        this.deceleration = 4.0;
        
        this.state = 'accelerating'; // accelerating, cruising, braking, waiting, crossing, departing
        this.intention = this.pickIntention();
        this.turnProgress = 0;

        this.buildRealisticCar();
        this.resetPosition();

        this.el.addEventListener('proceed-signal', () => {
            this.toggleTurnSignal(true);
            // Wait a moment (reaction time) then go
            setTimeout(() => { 
                this.state = 'crossing_accel'; 
            }, 600);
        });
      },

      pickIntention() {
        const r = Math.random();
        if (r < 0.50) return 'straight'; // 50% straight
        if (r < 0.75) return 'right';    // 25% right
        return 'left';                   // 25% left
      },

      buildRealisticCar() {
        // --- CHASSIS ---
        // Lower Body
        const body = document.createElement('a-box');
        body.setAttribute('scale', '1.8 0.5 4.2');
        body.setAttribute('position', '0 0.5 0');
        body.setAttribute('color', this.data.color);
        body.setAttribute('shadow', 'cast:true');
        this.el.appendChild(body);

        // Upper Cabin (Tapered)
        const cabin = document.createElement('a-box');
        cabin.setAttribute('scale', '1.6 0.5 2.2');
        cabin.setAttribute('position', '0 1.0 0.2');
        cabin.setAttribute('color', '#111'); // Dark tint windows
        this.el.appendChild(cabin);

        // Roof
        const roof = document.createElement('a-box');
        roof.setAttribute('scale', '1.62 0.1 2.25');
        roof.setAttribute('position', '0 1.3 0.2');
        roof.setAttribute('color', this.data.color);
        this.el.appendChild(roof);

        // --- LIGHTS ---
        // Headlights (Physical)
        this.addLight('-0.6', '0.5', '-2.1', '#fff', true);
        this.addLight('0.6', '0.5', '-2.1', '#fff', true);

        // Taillights (Physical + Brake logic)
        this.brakeLights = [];
        this.brakeLights.push(this.addLight('-0.6', '0.5', '2.1', '#500', false));
        this.brakeLights.push(this.addLight('0.6', '0.5', '2.1', '#500', false));

        // Turn Signals
        this.turnL = this.addSignal('-0.8', '0.5', '-2.1');
        this.turnR = this.addSignal('0.8', '0.5', '-2.1');

        // --- WHEELS ---
        const w1 = this.makeWheel(0.9, 0.35, 1.2);
        const w2 = this.makeWheel(-0.9, 0.35, 1.2);
        const w3 = this.makeWheel(0.9, 0.35, -1.2);
        const w4 = this.makeWheel(-0.9, 0.35, -1.2);
        this.el.appendChild(w1); this.el.appendChild(w2);
        this.el.appendChild(w3); this.el.appendChild(w4);
      },

      addLight(x, y, z, col, isFront) {
        const l = document.createElement('a-box');
        l.setAttribute('scale', '0.3 0.15 0.1');
        l.setAttribute('position', `${x} ${y} ${z}`);
        l.setAttribute('color', col);
        l.setAttribute('shader', 'flat');
        this.el.appendChild(l);
        
        // Add actual projected light for headlights
        if(isFront) {
            const beam = document.createElement('a-entity');
            beam.setAttribute('light', `type: spot; angle: 30; penumbra: 0.5; intensity: 1.5; color: #fff`);
            beam.setAttribute('rotation', '0 180 0'); // Face forward (local -z)
            l.appendChild(beam);
        }
        return l;
      },

      addSignal(x,y,z) {
        const s = document.createElement('a-sphere');
        s.setAttribute('radius', 0.1);
        s.setAttribute('position', `${x} ${y} ${z}`);
        s.setAttribute('color', 'orange');
        s.setAttribute('visible', false);
        this.el.appendChild(s);
        return s;
      },

      makeWheel(x,y,z) {
        const w = document.createElement('a-cylinder');
        w.setAttribute('rotation', '0 0 90');
        w.setAttribute('radius', 0.35);
        w.setAttribute('height', 0.2);
        w.setAttribute('color', '#222');
        w.setAttribute('position', `${x} ${y} ${z}`);
        
        // Hubcap
        const hub = document.createElement('a-cylinder');
        hub.setAttribute('radius', 0.2); hub.setAttribute('height', 0.22);
        hub.setAttribute('color', '#888');
        w.appendChild(hub);
        return w;
      },

      resetPosition() {
        const startDist = 80;
        if (this.data.axis === 'z') {
           const xPos = (this.data.dir === -1) ? this.laneOffset : -this.laneOffset;
           this.el.object3D.position.set(xPos, 0, startDist * -this.data.dir);
           this.el.object3D.rotation.y = (this.data.dir === 1) ? 0 : Math.PI;
        } else {
           const zPos = (this.data.dir === 1) ? this.laneOffset : -this.laneOffset;
           this.el.object3D.position.set(startDist * -this.data.dir, 0, zPos);
           this.el.object3D.rotation.y = (this.data.dir === 1) ? -Math.PI/2 : Math.PI/2;
        }
      },

      setBrakeLights(on) {
        const c = on ? '#f00' : '#500';
        this.brakeLights.forEach(l => l.setAttribute('color', c));
      },

      toggleTurnSignal(on) {
        if (!on) {
            this.turnL.setAttribute('visible', false);
            this.turnR.setAttribute('visible', false);
            return;
        }
        if (this.intention === 'left') this.turnL.setAttribute('visible', true);
        if (this.intention === 'right') this.turnR.setAttribute('visible', true);
      },

      scanTraffic() {
        // Basic Raycast Logic
        const myPos = (this.data.axis === 'z') ? this.el.object3D.position.z : this.el.object3D.position.x;
        const all = document.querySelectorAll('[car-controller]');
        let dist = 1000;

        for (let i = 0; i < all.length; i++) {
            if (all[i] === this.el) continue;
            const other = all[i].components['car-controller'];
            if (!other) continue;

            // Only check my lane
            if (other.data.axis === this.data.axis && other.data.dir === this.data.dir) {
                // Ignore cars that are departing (turning away)
                if (other.state === 'departing') continue;

                const otherPos = (this.data.axis === 'z') ? all[i].object3D.position.z : all[i].object3D.position.x;
                const d = (otherPos - myPos) * this.data.dir; 
                if (d > 0 && d < dist) dist = d;
            }
        }
        return dist;
      },

      tick(t, dt) {
        const delta = dt / 1000;
        const p = this.el.object3D.position;

        // --- STATE MACHINE & PHYSICS ---

        // 1. DRIVING / QUEUING
        if (this.state === 'accelerating' || this.state === 'cruising' || this.state === 'braking') {
            const distAhead = this.scanTraffic();
            const distToStop = Math.abs((this.data.axis === 'z' ? p.z : p.x)) - this.stopTarget;

            let targetSpeed = this.data.maxSpeed;

            // Collision Avoidance
            if (distAhead < 10) targetSpeed = 0; 
            
            // Stop Line Logic
            if (distToStop < 15 && distToStop > 0 && targetSpeed > 0) {
                 // Slow down for stop line
                 targetSpeed = Math.min(targetSpeed, distToStop * 1.5); // Ease out
            }

            // Physics Update
            if (this.currentSpeed < targetSpeed) {
                this.currentSpeed += this.acceleration * delta;
                if(this.currentSpeed > targetSpeed) this.currentSpeed = targetSpeed;
                this.setBrakeLights(false);
            } else if (this.currentSpeed > targetSpeed) {
                this.currentSpeed -= this.deceleration * delta;
                if(this.currentSpeed < targetSpeed) this.currentSpeed = targetSpeed;
                this.setBrakeLights(true); // Brake lights on when slowing
            }

            // Check if Stopped at Line
            if (distToStop <= 0.1 && this.currentSpeed < 0.1) {
                this.currentSpeed = 0;
                this.state = 'waiting';
                this.el.sceneEl.systems['traffic-arbiter'].registerArrival(this.el);
            }

        // 2. WAITING
        } else if (this.state === 'waiting') {
            this.currentSpeed = 0;
            this.setBrakeLights(true);

        // 3. CROSSING
        } else if (this.state === 'crossing_accel') {
            this.setBrakeLights(false);
            // Accelerate
            this.currentSpeed += this.acceleration * delta;
            if (this.currentSpeed > this.data.maxSpeed) this.currentSpeed = this.data.maxSpeed;

            if (this.intention === 'straight') {
                // Just move straight
            } else {
                // Arc Turn Logic
                const turnRate = (Math.PI / 2) * delta * 0.9;
                this.turnProgress += turnRate;

                if (this.intention === 'right') this.el.object3D.rotateY(-turnRate);
                else this.el.object3D.rotateY(turnRate * 0.8);

                if (this.turnProgress >= Math.PI/2) {
                    // Snap and depart
                    const y = this.el.object3D.rotation.y;
                    this.el.object3D.rotation.y = Math.round(y / (Math.PI/2)) * (Math.PI/2);
                    this.state = 'departing';
                    this.toggleTurnSignal(false);
                }
            }

            // Clearance Check
            const distSq = p.x*p.x + p.z*p.z;
            if (distSq > 150) { // >12m
                this.el.sceneEl.systems['traffic-arbiter'].notifyClear(this.el);
                if (this.intention === 'straight') this.state = 'departing';
            }
        } 
        else if (this.state === 'departing') {
             // Keep speed
             this.setBrakeLights(false);
             if (Math.abs(p.x) > 90 || Math.abs(p.z) > 90) this.el.remove();
        }

        // Apply movement vector locally (handles rotation automatically)
        this.el.object3D.translateZ(this.currentSpeed * delta);
      }
    });

    /* ======================================================================
       COMPONENT: ALIVE ENVIRONMENT
       ====================================================================== */
    AFRAME.registerComponent('alive-city', {
      init() {
        this.createQuadrant(-60, -14, -60, -14); // NW
        this.createQuadrant( 14, 60, -60, -14);  // NE
        this.createQuadrant(-60, -14,  14, 60);  // SW
        this.createQuadrant( 14, 60,  14, 60);   // SE
      },

      createQuadrant(minX, maxX, minZ, maxZ) {
        const w = maxX - minX;
        const h = maxZ - minZ;
        const cx = (minX + maxX) / 2;
        const cz = (minZ + maxZ) / 2;

        // 1. Curb (Raised concrete)
        const curb = document.createElement('a-box');
        curb.setAttribute('position', `${cx} 0.2 ${cz}`);
        curb.setAttribute('width', w); curb.setAttribute('depth', h); curb.setAttribute('height', 0.4);
        curb.setAttribute('color', '#95a5a6');
        this.el.appendChild(curb);

        // 2. Sidewalk (Darker pavement)
        const pav = document.createElement('a-plane');
        pav.setAttribute('position', `${cx} 0.41 ${cz}`);
        pav.setAttribute('width', w - 1); pav.setAttribute('height', h - 1);
        pav.setAttribute('rotation', '-90 0 0');
        pav.setAttribute('color', '#7f8c8d');
        this.el.appendChild(pav);

        // 3. Buildings (Procedural Heights + Windows)
        for (let x = minX + 5; x < maxX - 5; x += 12) {
            for (let z = minZ + 5; z < maxZ - 5; z += 12) {
                this.createBuilding(x, z);
            }
        }

        // 4. Street Props
        this.createLamp(maxX > 0 ? 13 : -13, maxZ > 0 ? 13 : -13); // Corner lamps
      },

      createBuilding(x, z) {
        const height = 8 + Math.random() * 15;
        const b = document.createElement('a-entity');
        b.setAttribute('position', `${x} ${height/2 + 0.4} ${z}`);

        const wall = document.createElement('a-box');
        wall.setAttribute('width', 9); wall.setAttribute('depth', 9); wall.setAttribute('height', height);
        wall.setAttribute('color', '#34495e');
        wall.setAttribute('shadow', 'cast:true; receive:true');
        b.appendChild(wall);

        // Lit Windows
        for(let y=1; y < height-2; y+=3) {
            this.addWindow(b, 0, y - height/2, 4.55); // Front
            this.addWindow(b, 4.55, y - height/2, 0, 90); // Side
        }
        this.el.appendChild(b);
      },

      addWindow(parent, x, y, z, rotY=0) {
        if(Math.random() > 0.6) return; // Randomize lit windows
        const w = document.createElement('a-plane');
        w.setAttribute('width', 1.5); w.setAttribute('height', 1.8);
        w.setAttribute('color', '#f1c40f');
        w.setAttribute('shader', 'flat');
        w.setAttribute('position', `${x} ${y} ${z}`);
        if(rotY) w.setAttribute('rotation', `0 ${rotY} 0`);
        parent.appendChild(w);
      },

      createLamp(x, z) {
        const l = document.createElement('a-entity');
        l.setAttribute('position', `${x} 0.4 ${z}`);
        
        const pole = document.createElement('a-cylinder');
        pole.setAttribute('height', 6); pole.setAttribute('radius', 0.15);
        pole.setAttribute('position', '0 3 0'); pole.setAttribute('color', '#222');
        l.appendChild(pole);

        const bulb = document.createElement('a-sphere');
        bulb.setAttribute('position', '0 6 0'); bulb.setAttribute('radius', 0.4);
        bulb.setAttribute('color', '#fff');
        bulb.setAttribute('material', 'emissive:#fff; emissiveIntensity:1.0');
        // Real light
        bulb.setAttribute('light', 'type:point; intensity:0.6; distance:20; color:#fff');
        l.appendChild(bulb);
        
        this.el.appendChild(l);
      }
    });

    // Helper: Stop Sign
    AFRAME.registerComponent('stop-sign', {
       schema: { rot: {type:'number'} },
       init() {
         const pole = document.createElement('a-cylinder');
         pole.setAttribute('color','#777'); pole.setAttribute('radius',0.05); pole.setAttribute('height',2.5); pole.setAttribute('position','0 1.25 0');
         const sign = document.createElement('a-circle');
         sign.setAttribute('color','#c0392b'); sign.setAttribute('radius',0.45); sign.setAttribute('position','0 2.5 0.06'); sign.setAttribute('side','double');
         const text = document.createElement('a-text');
         text.setAttribute('value', 'STOP'); text.setAttribute('align', 'center'); 
         text.setAttribute('scale', '0.9 0.9 0.9'); text.setAttribute('position', '0 2.5 0.07');
         this.el.appendChild(pole); this.el.appendChild(sign); this.el.appendChild(text);
         this.el.object3D.rotation.y = this.data.rot * (Math.PI/180);
       }
    });
  </script>
</head>

<body style="margin:0; background-color: #111;">
  <a-scene background="color: #050510" traffic-arbiter traffic-generator shadow="type: pcfsoft" fog="type: exponential; color: #1a1a2e; density: 0.008">

    <a-sky color="#050510"></a-sky> 
    <a-entity position="-40 20 -40">
        <a-sphere radius="1.5" color="#fff" shader="flat"></a-sphere>
        <a-entity light="type: directional; color: #aaccff; intensity: 0.4; castShadow:true"></a-entity>
    </a-entity>
    <a-entity light="type: ambient; color: #333; intensity: 0.5"></a-entity>

    <a-plane rotation="-90 0 0" width="200" height="200" color="#1a1a1a"></a-plane>

    <a-plane rotation="-90 0 0" position="0 0.02 0" width="10" height="150" color="#222"></a-plane>
    <a-plane rotation="-90 0 0" position="0 0.03 0" width="150" height="10" color="#222"></a-plane>
    
    <a-entity id="crosswalks" position="0 0.04 0">
        <a-plane rotation="-90 0 0" position="0 0 -7.5" width="10" height="1.5" color="white"></a-plane>
        <a-plane rotation="-90 0 0" position="0 0 7.5" width="10" height="1.5" color="white"></a-plane>
        <a-plane rotation="-90 0 0" position="-7.5 0 0" width="1.5" height="10" color="white"></a-plane>
        <a-plane rotation="-90 0 0" position="7.5 0 0" width="1.5" height="10" color="white"></a-plane>
    </a-entity>
    
    <a-plane rotation="-90 0 0" position="0 0.05 -8.5" width="4.5" height="0.3" color="white"></a-plane>
    <a-plane rotation="-90 0 0" position="0 0.05  8.5" width="4.5" height="0.3" color="white"></a-plane>
    <a-plane rotation="-90 0 0" position="-8.5 0.05 0" width="0.3" height="4.5" color="white"></a-plane>
    <a-plane rotation="-90 0 0" position=" 8.5 0.05 0" width="0.3" height="4.5" color="white"></a-plane>

    <a-entity alive-city></a-entity>
    
    <a-entity stop-sign="rot:0" position="-6.5 0 -8.5"></a-entity>
    <a-entity stop-sign="rot:-90" position="6.5 0 -8.5"></a-entity>
    <a-entity stop-sign="rot:180" position="6.5 0 8.5"></a-entity>
    <a-entity stop-sign="rot:90" position="-6.5 0 8.5"></a-entity>

    <a-entity id="rig" position="-18 2 18" rotation="0 -45 0" wasd-controls>
      <a-entity camera look-controls></a-entity>
    </a-entity>

  </a-scene>
</body>
</html>
